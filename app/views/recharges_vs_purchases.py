from pathlib import Path
from typing import Optional, List

import pandas as pd
import plotly.express as px
import streamlit as st

from app.pipelines.recharges_vs_purchases import (
    get_default_dataset_path,
    guess_columns,
    run_recharges_vs_purchases,
)


def _load_dataset(upload, path_text: str) -> Optional[pd.DataFrame]:
    """Load dataset from uploader or path text."""
    df = None
    if upload is not None:
        df = pd.read_csv(upload)
        st.caption("Loaded dataset from upload.")
    elif path_text:
        candidate_path = Path(path_text)
        if candidate_path.exists():
            df = pd.read_csv(candidate_path)
            st.caption(f"Loaded dataset from `{candidate_path}`.")
    return df


def render_recharges_vs_purchases() -> None:
    """Render Pearson correlation between recharges and purchases."""
    st.header("ðŸ“ˆ Recharges vs Purchases")
    st.markdown(
        "Question: **What is the total recharge activity generated by our customers in the analysis period, "
        "and how is that volume distributed across customers (e.g., the top 3 by recharges vs the rest)?**"
    )

    default_path = get_default_dataset_path()
    default_path_str = str(default_path) if default_path else ""

    uploaded_file = st.file_uploader("Upload recargas_vs_compras CSV", type=["csv"])
    custom_path = st.text_input(
        "Or read from local path",
        value=default_path_str,
        help="Example: data/recargas_vs_compras_20251128_214656.csv",
    )

    try:
        df = _load_dataset(uploaded_file, custom_path)
    except Exception as exc:
        st.error(f"Could not read the provided CSV: {exc}")
        return

    if df is None:
        st.info("Upload a CSV or provide a valid path to analyze recharges vs purchases.")
        return

    recharge_guess, purchase_guess = guess_columns(df)
    options = list(df.columns)

    # Try to suggest a customer identifier column for distribution calc
    id_candidates: List[str] = [
        c for c in options if c.lower() in ("user_id", "customer_id", "cliente_id")
    ]
    name_candidates: List[str] = [
        c for c in options if c.lower() in ("nombre", "name", "customer", "cliente", "user", "email")
    ]
    entity_default = id_candidates[0] if id_candidates else (name_candidates[0] if name_candidates else options[0])

    col1, col2 = st.columns(2)
    with col1:
        recharge_col = st.selectbox(
            "Recharge column",
            options,
            index=options.index(recharge_guess) if recharge_guess in options else 0,
            help="Typical: recharge_total, recharge_count, recharge_avg",
        )
    with col2:
        purchase_col = st.selectbox(
            "Purchase column",
            options,
            index=options.index(purchase_guess) if purchase_guess in options else 0,
            help="Typical: purchase_total, purchase_count, purchase_avg",
        )
    entity_col = st.selectbox(
        "Customer identifier (for distribution)",
        options,
        index=options.index(entity_default) if entity_default in options else 0,
        help="Used to sum recharges per customer (e.g., user_id or nombre).",
    )

    try:
        result = run_recharges_vs_purchases(
            df=df,
            recharge_col=recharge_col,
            purchase_col=purchase_col,
        )
    except Exception as exc:
        st.error(f"Could not compute correlation: {exc}")
        return

    corr = result["correlation"]
    pairs = result["pairs_used"]
    dropped = result["dropped_rows"]
    clean_df: pd.DataFrame = result["cleaned_df"]

    # Volume and correlation KPIs
    total_recharge = clean_df[recharge_col].sum()
    col_a, col_b, col_c = st.columns(3)
    with col_a:
        st.metric("Pearson r", f"{corr:.3f}" if corr is not None else "N/A")
    with col_b:
        st.metric("Pairs used", f"{pairs}")
    with col_c:
        st.metric("Rows dropped (non-numeric/NaN)", f"{dropped}")

    # Distribution: top 3 vs rest
    distribution = clean_df.groupby(entity_col)[recharge_col].sum().reset_index()
    distribution = distribution.sort_values(recharge_col, ascending=False)
    top3 = distribution.head(3)
    rest_total = distribution[recharge_col].sum() - top3[recharge_col].sum()

    st.subheader("Top recharge contributors vs rest")
    col_d, col_e = st.columns(2)
    with col_d:
        st.metric("Total recharge volume", f"{total_recharge:,.0f}")
    with col_e:
        top3_share = top3[recharge_col].sum() / total_recharge * 100 if total_recharge else 0
        st.metric("Top 3 share", f"{top3_share:.1f}%")

    # Small bar chart: top 3 + rest
    dist_chart = top3.copy()
    dist_chart[entity_col] = dist_chart[entity_col].astype(str)
    dist_chart = pd.concat(
        [
            dist_chart,
            pd.DataFrame(
                [{entity_col: "Others", recharge_col: max(rest_total, 0)}]
            ),
        ],
        ignore_index=True,
    )
    fig_dist = px.bar(
        dist_chart,
        x=entity_col,
        y=recharge_col,
        title="Recharge volume: Top 3 customers vs rest",
        labels={entity_col: "Customer", recharge_col: "Recharge volume"},
    )
    fig_dist.update_traces(text=dist_chart[recharge_col], textposition="outside")
    st.plotly_chart(fig_dist, use_container_width=True)

    if corr is None or pairs < 2:
        st.info("Not enough valid pairs to compute Pearson correlation.")
        return

    st.subheader("Scatter: Recharges vs Purchases")
    fig = px.scatter(
        clean_df,
        x=recharge_col,
        y=purchase_col,
        labels={recharge_col: "Recharges", purchase_col: "Purchases"},
        trendline=None,
        title="Relationship between recharges and purchases",
    )
    st.plotly_chart(fig, use_container_width=True)

    st.subheader("Sample data (cleaned)")
    st.dataframe(clean_df[[recharge_col, purchase_col]].head(20), hide_index=True, use_container_width=True)

    st.download_button(
        "ðŸ“¥ Download cleaned dataset",
        data=clean_df.to_csv(index=False).encode("utf-8"),
        file_name="recargas_vs_compras_cleaned.csv",
        mime="text/csv",
    )
